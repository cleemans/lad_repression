
# knitr document van Steensel lab

# Thethered TRIP
## Christ Leemans, 31-05-2016 - to date 

## Introduction
Laura performed a thetered-TRIP experiment on a K562 cell pool. She transiently transfected the cell pool with GAL4 thetered to 3 different "proteins of interest"(POI), namely G9a, the KRAB domain and CBX5. She took measurements after day 2 to see the initial effect of the thetering and after 12, 11 and 9 days respectively to see if there was any memory of the silencing on day 2. Besides the thetered GAL4-POI, two seperate controlls were taken using unthetered GAL4 and unthethered POI.

## Experimental setup
At this moment Laura has data for 3 different tethering experiments using KRAB, G9a and CBX5. For each protein of interest (POI) there are 12 expression and 12 gDNA files: 3 conditions * 2 different days after induction * 2 replicates. One condition uses an unthethered POI, the second uses only GAL4 and the third condition uses the POI thethered to GAL4 (GAL4-POI). Expression and gDNA data was obtained on day 2 and day 9. With each sequencing run, spikeins were added to normalize across different experiments. There is a different config file to extract the expression values of the spikeins.

## Description of data
For this part of the analysis I used the data that was generated previously in the data preperation report: cl20160713_TRIP_K562_data_preperation. 
The .RData produced contains a large data frame with a row for each barcode and the following columns:

| column name | description |
| ----------- | ----------- |
| CBX_GAL4_exp_2 | expression after thetering GAL4 on day 2  for CBX5 experiment |
| CBX_GAL4_exp_9 | expression after thetering GAL4 on day 9 for CBX5 experiment |
| CBX_GAL4.POI_exp_2 | expression after thetering GAL4-CBX5 on day 2 |
| CBX_GAL4.POI_exp_9 | expression after thetering GAL4-CBX5 on day 9 |
| CBX_POI_exp_2 | expression after thetering CBX5 on day 2 |
| CBX_POI_exp_9 | expression after thetering CBX5 on day 9 |
| G9a_GAL4_exp_12 | expression after thetering GAL4 on day 12 for G9a experiment |
| G9a_GAL4_exp_2 | expression after thetering GAL4 on day 2 for G9a experiment |
| G9a_GAL4.POI_exp_12 | expression after thetering GAL4-G9a on day 12 |
| G9a_GAL4.POI_exp_2 | expression after thetering GAL4-G9a on day 2 |
| G9a_POI_exp_12 | expression after thetering G9a on day 12 |
| G9a_POI_exp_2 | expression after thetering G9a on day 2 |
| KRAB_GAL4_exp_11 | expression after thetering GAL4 on day 11 for KRAB experiment |
| KRAB_GAL4_exp_2 | expression after thetering GAL4 on day 2 for KRAB experiment |
| KRAB_GAL4.POI_exp_11 | expression after thetering GAL4-KRAB on day 11 |
| KRAB_GAL4.POI_exp_2 | expression after thetering GAL4-KRAB on day 2 |
| KRAB_POI_exp_11 | expression after thetering KRAB on day 11 |
| KRAB_POI_exp_2 | expression after thetering KRAB on day 2 |
| CBX_GPvsP_day2 | fold change GAL4-CBX5 vs CBX5 on day 2 |
| CBX_GPvsP_day9 | fold change GAL4-CBX5 vs CBX5 on day 9 |
| G9a_GPvsP_day12 | fold change GAL4-G9a vs G9a on day 12 |
| G9a_GPvsP_day2 | fold change GAL4-G9a vs G9a on day 2 |
| KRAB_GPvsP_day11 | fold change GAL4-KRAB vs KRAB on day 11 |
| KRAB_GPvsP_day2 | fold change GAL4-KRAB vs KRAB on day 2 |
| CBX_GPvsG_day2 | fold change GAL4-CBX5 vs GAL4 on day 2 |
| CBX_GPvsG_day9 | fold change GAL4-CBX5 vs GAL4 on day 9 |
| G9a_GPvsG_day12 | fold change GAL4-G9a vs GAL4 on day 12 |
| G9a_GPvsG_day2 | fold change GAL4-G9a vs GAL4 on day 2 |
| KRAB_GPvsG_day11 | fold change GAL4-KRAB vs GAL4 on day 11 |
| KRAB_GPvsG_day2 | fold change GAL4-KRAB vs GAL4 on day 2 |
| CBX_PvsG_day2 | fold change CBX5 vs GAL4 on day 2 |
| CBX_PvsG_day9 | fold change CBX5 vs GAL4 on day 9 |
| G9a_PvsG_day12 | fold change G9a vs GAL4 on day 12 |
| G9a_PvsG_day2 | fold change G9a vs GAL4 on day 2 |
| KRAB_PvsG_day11 | fold change KRAB vs GAL4 on day 11 |
| KRAB_PvsG_day2 | fold change KRAB vs GAL4 on day 2 |
| G9a_D2_above_norm_cut | all normalization read-counts for G9a > 50 on day 2 |
| G9a_D12_above_norm_cut | all normalization read-counts for G9a > 50 on day 12 |
| CBX_D2_above_norm_cut | all normalization read-counts for CBX5 > 50 on day 2 |
| CBX_D9_above_norm_cut | all normalization read-counts for CBX5 > 50 on day 9 |
| KRAB_D2_above_norm_cut | all normalization read-counts for G9a > 50 on day 2 |
| KRAB_D11_above_norm_cut | all normalization read-counts for G9a > 50 on day 11 |
| chr_f | chromosome of forward mapping read |
| ori_f | orientation of forward mapping read |
| pos_f | location of forward read on the chromosome |
| t_reads_f | total number of forward reads |
| mapq_f | average mapping quality of forward reads mapped to the same location |
| freq1_f | frequency of forward reads mapped to the primary location |
| freq2_f | frequency of forward reads mapped to a possible secondary location |
| chr_r | chromosome of reverse mapping read |
| ori_r | orientation of reverse mapping read |
| pos_r | location of reverse read on the chromosome |
| t_reads_r | total number of reverse reads |
| mapq_r | average mapping quality of reverse reads mapped to the same location |
| freq1_r | frequency of reverse reads mapped to the primary location |
| freq2_r | frequency of reverse reads mapped to a possible secondary location |
| unique_map | according to the thresholds set in the data preperation, is the barcode uniquely mapped |
| rep_family | with which repeat family (repeatmasker nomenclature) does the barcode overlap |
| rep_name | with which repeat name (repeatmasker nomenclature) does the barcode overlap |
| lad | with which state of lamina association does the barcode overlap (constitutive LAD, facultative LAD, faculatative interLAD or constitutive interLAD) |
| chrom | with which of the 12 state chromatin model does the barcode overlap |
| unique_rep_name | does the barcode map to a single repeat name according to the thresholds set |
| unique_rep_family | does the barcode map to a single repeat family according to the thresholds set |
| unique_lad | does the barcode map to a single LAD-state according to the thresholds set |
| unique_chrom | does the barcode map to a single chromatin state according to the thresholds set |



## Path, Libraries, Parameters and Useful Functions

```{r functions}
opts_chunk$set(out.width='750px', dpi=200)
StartTime <-Sys.time()

# 6-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),3,8) 

# libraries:
library(stringr)
library(ggplot2)
library(reshape2)
library(knitr)
library(gridExtra)
library(plyr)
library(grid)


load('../results/TTRIP_K562_FC_exp.rData')


# just so I can sellect the right day for each protein of interest in the loops
days = list(KRAB=c(11,14), G9a=12 ,CBX=c(9,12))
conditions = c('GAL4.POI', 'POI', 'GAL4')



filter_data <- function(fc_table, condition_vec, poi, day, type_vec, state_vec=NA, unique_map=F){
	# Filter the data for a specific experiment (e.g. GAL4-KRAB vs GAL4 on day 2)
	# Check the data preperation script for a more in depth look on the different
	# selection criteria.
	#
	# Args:
	#   fc_table: the big data-frame with all data.
	#   conditionx: the column name with the classification/expression/fold change that should be on the x-axis
	#   conditiony: the column name with the classification/expression/fold change that should be on the y-axis
	#   poi: the protein of interest in this experiment
	#   day: the day of the experiment
	#   xtype: what is the type of data for the x column?
	#          Used to transform the data correctly [value, factor or log2]
	#   ytype: what is the type of data for the y column?
	#          Used to transform the data correctly [value, factor or log2]
	#   state: optional value to add a state definition as a third column.
	# Returns:
	#   A filtered data frame with an x and y column, the x column contains a factor with
	#   the classification, the y column contains log2 transformed values of the experiment.
	total = nrow(fc_table)
	# check if the normalization counts are above 50 for each sample
	above_norm = sprintf('%s_D%i_above_norm_cut', poi, day)
	if (length(above_norm)>1){
		fc_table = fc_table[apply(fc_table[,above_norm],1, all),]
	} else{
		fc_table = fc_table[fc_table[,above_norm], ]
	}
	col_names = condition_vec
	summary_table = data.frame(cutoff=rep(NA, 5),
							   removed=rep(0, 5),
							   left=rep(0, 5),
							   stringsAsFactors=F)
	summary_table[1,] = list('above norm-count of 50', 
		                     total - nrow(fc_table),
		                     nrow(fc_table))
	# is the barcode uniquely linked to a single classification for clasifications used
	
	cd_matrix = cbind(type_vec, condition_vec)
	if (any(!is.na(state_vec))){
		cd_matrix = rbind(cd_matrix, cbind('factor', state_vec))
		col_names = c(col_names, state_vec)
	}
	if (unique_map){
		cd_matrix = rbind(cd_matrix, c('map', 'map'))
	}
	for (i in 1:nrow(cd_matrix)){
		type = cd_matrix[i,1]
		if (type != 'map'){
			name = cd_matrix[i,2]
			unique_name = paste0('unique_',name)
			if (unique_name %in% colnames(fc_table)){
				fc_table = fc_table[fc_table[,unique_name] | fc_table[,name]=='-',]
			}
		}
		else if(type == 'map'){
			fc_table = fc_table[fc_table[,'unique_map'],]
		}
	}
	summary_table[2, ] = list('unique barcode-state link',
				              summary_table[1,'left'] - nrow(fc_table),
				              nrow(fc_table))

	# check if the log2 expression for the barcode of the GAL4 control > 0
	base_exp = sprintf('%s_GAL4_exp_%s',poi, day)
	above_exp_cut = fc_table[,base_exp]>0
	if (length(base_exp)>1){
		fc_table = fc_table[apply(above_exp_cut,1, all),]
	} else{
		fc_table = fc_table[above_exp_cut, ]
	}
	summary_table[3, ] = list('log2 base expression > 0', 
		                      summary_table[2,'left'] - nrow(fc_table),
	                          nrow(fc_table))
	

	# create a factor column x with the classification
	# the order can be important for the order in which the data is later represented in a plot.
	xy_list = list()
	for (i in 1:nrow(cd_matrix)){
		type = cd_matrix[i,1]
		condition = cd_matrix[i,2]
		if (type == 'factor'){
			if (condition == 'lad'){
				new_values = factor(fc_table[,condition], levels=c('cLAD','fLAD', 'fiLAD', 'ciLAD', '-'))
			} else if(condition=='chrom'){
				chrom_levels = unique(fc_table[,condition])
				chrom_levels = chrom_levels[!is.na(chrom_levels)]
				# sort on the number in the state name
				chrom_levels = chrom_levels[order(sapply(chrom_levels,function(x){
					# if the state is unknown, return a high number so that it ends up at the end of the sort
					if (x!='-'){
						return(as.numeric(str_split(x,'_')[[1]][1]))
					} else{
						return(Inf)
					}}))]
				new_values = factor(fc_table[,condition], levels=chrom_levels)
			} else {
				new_values = factor(fc_table[,condition])
			}
			
		} else if (type=='log2'){
			new_values = log2(fc_table[,condition] + 0.01)
		} else if (type != 'map'){
	    	new_values = fc_table[,condition]
		}
		if (type != 'map'){
			xy_list[[i]] = new_values
		}
	}
	xy_table=data.frame(xy_list)

	colnames(xy_table) = col_names
	rownames(xy_table) = rownames(fc_table)
	xy_table = data.frame(xy_table)
	for (condition in condition_vec){
		xy_table = xy_table[!is.na(xy_table[,condition]), ]
	}
	summary_table[4, ] = list('not NA', 
		                      summary_table[3,'left'] - nrow(xy_table),
	                          nrow(xy_table))

	for (condition in condition_vec){
		xy_table = xy_table[!is.infinite(xy_table[,condition]), ]
	}
	summary_table[5, ] = list('not infinite', 
		                      summary_table[4,'left'] - nrow(xy_table),
	                          nrow(xy_table))
	return(list(xy_table, summary_table))
}

```


## density pattern of expression at memory days
In previous scatterplots of there appeared to be a specific subset of barcodes that had memory in repressive chromatin states, late replicating DNA and LADs. We wondered if this could also be seen in density plots. If there would be a particular subset having "memmory"  this should result in a bimodal distribution, whereas, when there is a general effect of "memmory", the unimodal distribution would be shifted as a whole (using "", since real memmory is not proven).

I put vertical lines at the 2,5% and 92,5% of the GAL4 controll.


```{r density_expression, fig.width=10, fig.height=50}
for (poi in names(days)){
	for (day in days[[poi]]){
		condition_vec = sprintf('%s_%s_exp_%i', poi, conditions, day)
		xy_table = filter_data(fc_table, condition_vec, poi, day, rep('log2',3), state_vec=c('lad_2state','chrom', 'segment'), unique_map=F)
		xy_melt = melt(xy_table[[1]], measure.vars=condition_vec)
		cdat = ddply(xy_melt, "variable", summarise, confint=quantile(value, c(0.025, 0.975)))
		cdat_lad = ddply(xy_melt, c("variable",'lad_2state'), summarise, confint=quantile(value, c(0.025, 0.975)))
		cdat_segment = ddply(xy_melt, c("variable",'segment'), summarise, confint=quantile(value, c(0.025, 0.975)))
		cdat_chrom = ddply(xy_melt, c("variable",'chrom'), summarise, confint=quantile(value, c(0.025, 0.975)))
		p1=ggplot(xy_melt , aes(x=value, colour=variable)) + geom_density() + geom_vline(data = cdat[cdat$variable==condition_vec[3],], aes(xintercept=as.numeric(confint), color=factor(variable)))
		p2=ggplot(xy_melt , aes(x=value, colour=variable)) + geom_density() + geom_vline(data = cdat_lad[cdat_lad$variable==condition_vec[3],], aes(xintercept=as.numeric(confint), color=factor(variable))) + facet_wrap(~ lad_2state, ncol=2)
		p3=ggplot(xy_melt , aes(x=value, colour=variable)) + geom_density() + geom_vline(data = cdat_segment[cdat_segment$variable==condition_vec[3],], aes(xintercept=as.numeric(confint), color=factor(variable))) + facet_wrap(~ segment, ncol=2)
		p4=ggplot(xy_melt , aes(x=value, colour=variable)) + geom_density() + geom_vline(data = cdat_chrom[cdat_chrom$variable==condition_vec[3],], aes(xintercept=as.numeric(confint), color=factor(variable))) + facet_wrap(~ chrom, ncol=3)
		grid.arrange(p1, p2, p3, p4, heights=c(1,2,3,6))
	}
}
```
**conclusion:**
There are often already small bumbs in the density with a group of low expressing barcodes in the controll groups. But this bumb seems to get larger with the GAL4-POI construct. In the KRAB day 11 experiment, the main peak is shifted and barcode expression in general is lower, this does not a big effect and it can be either biological or technical, but this makes it a bit harder to detect a bimodal distribution.

## density pattern of fold change at memory days
There was already some slight bimodality in previous plots, so to distinguish between barcodes thate were previously low expressing and barcodes which became lowly expressing, 

I put vertical lines at the 2,5% and 92,5% of the POI vs GAL4 controll.

```{r density_foldchange, fig.width=10, fig.height=40}
vs = c('GPvsG', 'GPvsP', 'PvsG')
for (poi in names(days)){
	for (day in days[[poi]]){
		condition_vec = sprintf('%s_%s_day%i', poi, vs, day)
		xy_table = filter_data(fc_table, condition_vec, poi, day, rep('log2',3), state_vec=c('lad_2state','chrom', 'segment'), unique_map=F)
		xy_melt = melt(cbind(xy_table[[1]], barcode=rownames(xy_table[[1]])), measure.vars=condition_vec)
		cdat = ddply(xy_melt, "variable", summarise, confint=quantile(value, c(0.025, 0.975)))
		cdat_lad = ddply(xy_melt, c("variable",'lad_2state'), summarise, confint=quantile(value, c(0.025, 0.975)))
		cdat_segment = ddply(xy_melt, c("variable",'segment'), summarise, confint=quantile(value, c(0.025, 0.975)))
		cdat_chrom = ddply(xy_melt, c("variable",'chrom'), summarise, confint=quantile(value, c(0.025, 0.975)))
		p1=ggplot(xy_melt , aes(x=value, colour=variable)) + geom_density() + geom_vline(data = cdat[cdat$variable==condition_vec[3],], aes(xintercept=as.numeric(confint), color=factor(variable)))
		p2=ggplot(xy_melt , aes(x=value, colour=variable)) + geom_density() + geom_vline(data = cdat_lad[cdat_lad$variable==condition_vec[3],], aes(xintercept=as.numeric(confint), color=factor(variable))) + facet_wrap(~ lad_2state, ncol=2)
		p3=ggplot(xy_melt , aes(x=value, colour=variable)) + geom_density() + geom_vline(data = cdat_segment[cdat_segment$variable==condition_vec[3],], aes(xintercept=as.numeric(confint), color=factor(variable))) + facet_wrap(~ segment, ncol=2)
		p4=ggplot(xy_melt , aes(x=value, colour=variable)) + geom_density() + geom_vline(data = cdat_chrom[cdat_chrom$variable==condition_vec[3],], aes(xintercept=as.numeric(confint), color=factor(variable))) + facet_wrap(~ chrom, ncol=3)
		grid.arrange(p1, p2, p3, p4, heights=c(1,2,3,6))
	}
}
```
**conclusion:**
At this resolution it is dificult to have a clear distinction between the two peaks of a potential bimodal distribution, although it does seem like some plots are hinting more towards a bimodal distribution than towards a general shift in expression as seen on day 2.
Gal4-CBX vs GAL4 at day 12 shows a really nice bimodal distribution, unfortunately this is different from the GAL4-CBX vs CBX fold changes, although there still seems to be some bimodality there as well. This can also be seen in the hight of the central peak.


## violin plots

We can also show violin plots with the same data, this might look nicer.

```{r violin_over, fig.width=10, fig.height=15}
for (poi in names(days)){
	for (day in days[[poi]]){
		condition_vec = sprintf('%s_%s_day%i', poi, vs, day)
		xy_table = filter_data(fc_table, condition_vec, poi, day, rep('log2',3), state_vec=c('lad_2state','chrom', 'segment'), unique_map=F)

		p1 = ggplot(xy_table[[1]], aes(x=factor(segment, levels=c('ERD','TZ','LRD','-')))) + labs(x='replication segment', colour='replication segment')
		for (condition in factor(condition_vec)){
			p1 = p1 + geom_violin(data=cbind(xy_table[[1]], colour=condition), aes_string(y=condition, colour='colour'), alpha=0.3)
		}
		p2 = ggplot(xy_table[[1]], aes(x=factor(lad_2state, levels=c('LAD','interLAD', '-')))) + labs(x='lad state', colour='lad state')
		for (condition in factor(condition_vec)){
			p2 = p2 + geom_violin(data=cbind(xy_table[[1]], colour=condition), aes_string(y=condition, colour='colour'), alpha=0.3)
		}
		p3 = ggplot(xy_table[[1]], aes(x=factor(chrom))) + labs(x='chrom state', colour='chrom state') +
            theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))
		for (condition in factor(condition_vec)){
			p3 = p3 + geom_violin(data=cbind(xy_table[[1]], colour=condition), aes_string(y=condition, colour='colour'), alpha=0.3)
		}
		grid.arrange(p1, p2, p3)

	}
}

```
## violin plots with data points

Unfortulately with the previous violin plots we've lost the information on the sizes of each grouping. We could also overlay the data points, and plot the different conditions seperately.

```{r violin_points, fig.width=10, fig.height=15}
for (poi in names(days)){
	for (day in days[[poi]]){
		condition_vec = sprintf('%s_%s_day%i', poi, vs, day)
		xy_table = filter_data(fc_table, condition_vec, poi, day, rep('log2',3), state_vec=c('lad_2state','chrom', 'segment'), unique_map=F)
		for (condition in condition_vec){
			p1 = ggplot(xy_table[[1]], aes(x=segment, colour=segment)) + labs(x='replication segment', colour='replication segment') + geom_point(aes_string(y=condition), position=position_jitter(width=0.9), size=0.6, alpha=0.4) + geom_violin(aes_string(y=condition), alpha=0.4)
			p2 = ggplot(xy_table[[1]], aes(x=lad_2state, colour=lad_2state)) + labs(x='lad state', colour='lad state') + geom_point(aes_string(y=condition), position=position_jitter(width=0.9), size=0.6, alpha=0.4) + geom_violin(aes_string(y=condition), alpha=0.4)
			p3 = ggplot(xy_table[[1]], aes(x=chrom, colour=chrom)) + labs(x='chromatin state', colour='chromatin state') +geom_point(aes_string(y=condition), position=position_jitter(width=0.9), size=0.6, alpha=0.4) + theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))+ geom_violin(aes_string(y=condition), alpha=0.4)
			grid.arrange(p1, p2, p3, top=textGrob(condition, gp=gpar(fontsize=38)))
		}
	}
}

```

## cut-off for memory state

Untill now we looked at a continuous scale of 'memory', comparing fold change of fusion vs controls. But another approach would be to split the data into two sets of either memory barcodes or non memory barcodes. Since there seems to be a bimodal distribution, this could be a good approach. Looking at the plots from the beginning, the limits set at around the 95% quantile of the control are capable of splitting memory from non-memory in the KRAB experiment of day 11 fairly well in lamina associated barcodes. Last report I showed both, but let's just use fold-change based approach since there is a lot of overlap and fold-change makes more sense.

```{r memory_state}
poi = 'KRAB'
day = 11
conditions = c('GPvsG', 'GPvsP', 'PvsG')
condition_vec = sprintf('%s_%s_day%i', poi, conditions, day)
xy_table = filter_data(fc_table, condition_vec, poi, day, rep('log2',3), state_vec=c('lad_2state'), unique_map=F)
xy_melt = melt(xy_table[[1]], measure.vars=condition_vec)
cdat = ddply(xy_melt, "variable", summarise, confint=quantile(value, c(0.025, 0.975)))
cdat_lad = ddply(xy_melt, c("variable",'lad_2state'), summarise, confint=quantile(value, c(0.025, 0.975)))

ggplot(xy_melt[xy_melt$lad_2state=='LAD', ] , aes(x=value, colour=variable)) + geom_density() + geom_vline(data = cdat_lad[cdat_lad$variable==condition_vec[3] & cdat_lad$lad_2state=='LAD',], aes(xintercept=as.numeric(confint), color=factor(variable)))
cut_off = min(cdat_lad[cdat_lad$variable=='KRAB_PvsG_day11' & cdat_lad$lad_2state=='LAD','confint'])
below_cut = rownames(xy_table[[1]])[which(xy_table[[1]]$KRAB_GPvsG_day11 < cut_off & xy_table[[1]]$lad_2state == 'LAD' )]

above_cut = rownames(xy_table[[1]])[which(xy_table[[1]]$KRAB_GPvsG_day11 >= cut_off & xy_table[[1]]$lad_2state == 'LAD' )]

memory_fc = rbind(cbind(memory='YES', fc_table[below_cut,]), cbind(memory='NO', fc_table[above_cut,]))

## check expression and fold_change difference's
ggplot(memory_fc , aes(x=log2(KRAB_GAL4.POI_exp_11 + 0.1), colour=memory)) + geom_density() + ggtitle('KRAB GAL4-fusion expression\nsplit by memory (fold-change based)')
ggplot(memory_fc , aes(x=log2(KRAB_GAL4_exp_11 + 0.1), colour=memory)) + geom_density() + ggtitle('KRAB experiment GAL4 expression\nsplit by memory (fold-change based)')
ggplot(memory_fc , aes(x=log2(KRAB_GPvsG_day11 + 0.1), colour=memory)) + geom_density() + ggtitle('KRAB experiment fold-change\nGAL4-fusion over GAL4\nsplit by memory (fold-change based)')

## look at distances to different factors that might play a role
ggplot(memory_fc[which(memory_fc$unique_cpg_distance==T),] , aes(x=log2(abs(cpg_distance) + 0.1), colour=memory)) + geom_density(adjust=1/2) + ggtitle('KRAB experiment barcode\ndistance to nearest cpg\nsplit by memory (fold-change based)')
ggplot(memory_fc[which(memory_fc$unique_ctcf_distance==T),] , aes(x=log2(abs(ctcf_distance) + 0.1), colour=memory)) + geom_density(adjust=1/2) + ggtitle('KRAB experiment barcode\ndistance to nearest ctcf\nsplit by memory (fold-change based)')

## we can combine telomere and centromere distance to compensate for differences in chromosome arm size
unique = which(memory_fc$unique_centromere_distance==T & memory_fc$unique_telomere_distance==T)
ggplot(memory_fc[unique,] , aes(x=abs(centromere_distance)/(abs(telomere_distance)+abs(centromere_distance)) , colour=memory)) + geom_density(adjust=1/2) + ggtitle('KRAB experiment barcode\nposition on chromosome arm\nsplit by memory (fold-change based)\n(0 = centromere, 1 = telomere)') + xlab('distance from centromere / distance between centromere and telomere')
## while we are added, lets see if the size of the chromosome arm matters
ggplot(memory_fc[unique,] , aes(x=log2(abs(telomere_distance)+abs(centromere_distance)) , colour=memory)) + geom_density(adjust=1/2) + ggtitle('KRAB experiment barcode\nsize of chromosome arm\nsplit by memory (fold-change based)') + xlab('log2(distance between centromere and telomere)')
chrom_sizes = read.table('../../../data/hg19/hg19.chrom.sizes',row.names=1)
memory_fc$chrom_size = chrom_sizes[memory_fc$chr_r,]
ggplot(memory_fc[memory_fc$unique_map,] , aes(x=log2(chrom_size) , colour=memory)) + geom_density(adjust=1/2) + ggtitle('KRAB experiment barcode\nsize of chromosome\nsplit by memory (fold-change based)') + xlab('log2(chromosome size)')
memory_fc$chr_r = factor(memory_fc$chr_r, levels=rownames(chrom_sizes)[1:24])
ggplot(memory_fc[memory_fc$unique_map,] , aes(x=chr_r, fill=memory)) + geom_bar(position='dodge') + ggtitle('KRAB experiment barcode\nchromosomes\nsplit by memory (fold-change based)') + xlab('chromosome') + theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))

ggplot(memory_fc[which(memory_fc$unique_gene_distance==T),] , aes(x=log2(abs(gene_distance)/1000 + 1), colour=memory)) + geom_density(adjust=1/3) + ggtitle('KRAB experiment barcode\ndistance to nearest gene\nsplit by memory (fold-change based)') + xlab('log2(kb gene distance + 1)')
```

**conclusion:**
Memory barcodes tend to be more intergrated towards the telomeres away from centromeres. Distance to cpg's and ctcf sites seem to show less differences. Also there seems to be less memory barcodes intergrated inside gene bodies. What is striking, is that there seems to be a higher ratio of barcodes integrated in chromosome 9 and 13 showing memory.



## replication timing of memory in LADs

Now that we have 2 groups (memory and no memory) we can make more intuitive plots of 'raw' repliction timing data.
This replication timing data contains for 6 different points in the cell cycle normalized density of BrdU-DNA-derived sequence tags in 50kb windows. The following quote from the [material and methods](http://www.pnas.org/content/suppl/2009/12/17/0912402107.DCSupplemental/pnas.200912402SI.pdf#nameddest=STXT ) of [Hansen et al. (2010)](http://www.pnas.org/content/107/1/139.long) 

The following excerpt explains how data was normalized:
> After filtering bad spots, the density of BrdU-DNA-derived sequence tags along the genome was calculated for each cell-cycle fraction using 50 kb sliding windows at 1 kb intervals. These tag densities were then normalized to a global density of 4 million tags per genome for each fraction [because flow cytometry windows suggest that the G1b- and S-phase fractions represent equivalent increases in DNA content, and the number of S-phase cells in the G2/M fraction is similar to the others by cell-cycle analysis (MultiCycle AVsoftware, Phoenix Flow Systems, San Diego, CA)]. To avoid potential variability in signal and background related to tag mapability variation, sequence bias, or copy-number differences, we further normalized the 50 kb densities of each cell line to a percentage of total replication for that line at each genomic coordinate [as was originally done for our STS-based replication time analysis (5)].

```{r rep_timing, fig.width=10, fig.height=15}
for (fase in c('G1', 'S1', 'S2', 'S3', 'S4', 'G2')){
	signal = paste0('signal_', fase)
	unique = which(memory_fc[,paste0('unique_', signal)])
	p1 = ggplot(memory_fc[unique,] , aes_string(x='memory', y=paste0('as.numeric(',signal, ')'), colour='memory')) + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))+ geom_violin(alpha=0.4) + ggtitle(sprintf('KRAB experiment barcode\n%s signal\nsplit by memory (fold-change based)', fase))
	p2 = ggplot(memory_fc[unique,] , aes_string(x=paste0('as.numeric(',signal, ')'), colour='memory')) + geom_density() + ggtitle(sprintf('KRAB experiment barcode\n%s signal\nsplit by memory (fold-change based)', fase) )
	grid.arrange(p1, p2)
}

```

## barcodes in G2

After previous plots I would like to know how well G2 signal can split the barcodes into memory and non-memory. Do the barcodes that replicate at G2, not classified as 'memory' still lean towards memory in the distribution.

```{r G2}
poi = 'KRAB'
day = 11
conditions = c('GPvsG', 'GPvsP', 'PvsG')
condition_vec = sprintf('%s_%s_day%i', poi, conditions, day)
xy_table = filter_data(fc_table, condition_vec, poi, day, rep('log2',3), state_vec=c('signal_G2', 'lad_2state'), unique_map=F)
xy_G2 = xy_table[[1]]
xy_G2$signal_G2 = as.numeric(xy_G2$signal_G2)
# let's choose a cut-off
ggplot(xy_G2 , aes(x=signal_G2)) + geom_density() + ggtitle('KRAB experiment barcode\ndistance to telomere\nsplit by memory (fold-change based)')
# 20 seems fair
xy_G2$G2 = '-'
xy_G2$G2[which(xy_G2$signal_G2 >= 20)] = 'G2'
xy_G2$G2[which(xy_G2$signal_G2 < 20)] = 'NOT G2'

ggplot(xy_G2 , aes(x=KRAB_GPvsG_day11, colour=G2)) + geom_density() + ggtitle('KRAB Gal4-fusion over GAL4\nbarcode split by G2 signal (fold-change)')

ggplot(xy_G2[xy_G2$lad_2state=='LAD', ] , aes(x=KRAB_GPvsG_day11, colour=G2)) + geom_density() + ggtitle('KRAB Gal4-fusion over GAL4\nbarcode split by G2 signal (fold-change)')


## but if we look back at the plot of our memmory group, 45 seems like a more logical cut-off
xy_G2$G2 = '-'
xy_G2$G2[which(xy_G2$signal_G2 >= 45)] = 'G2'
xy_G2$G2[which(xy_G2$signal_G2 < 45)] = 'NOT G2'


ggplot(xy_G2 , aes(x=KRAB_GPvsG_day11, colour=G2)) + geom_density() + ggtitle('KRAB Gal4-fusion over GAL4\nbarcode split by G2 signal (fold-change)')

ggplot(xy_G2[xy_G2$lad_2state=='LAD', ] , aes(x=KRAB_GPvsG_day11, colour=G2)) + geom_density() + ggtitle('KRAB Gal4-fusion over GAL4\nbarcode split by G2 signal (fold-change)')
```
**conclusion:**
Although a big part of the barcodes that show memory on day 11 are really late replicating, just splitting by replication signal in G2 on it's own is not able to explain memory. A large part of those barcodes follow the normal distribution with the others of the non-memory group.
Doesn't leave out a role for replication timing, but clearly it's more. Maybe if we go deeper in the degree of lamina interaction we can explain the memory better.


## AT ratio of memory in LADs
Maybe the memory effect correlates with AT-richness of the region

```{r at_ratio, fig.width=10, fig.height=15}
unique = which(memory_fc$unique_AT_ratio)
p1 = ggplot(memory_fc[unique,] , aes(x=memory, y=as.numeric(AT_ratio), colour=memory)) + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))+ geom_violin(alpha=0.4) + ggtitle('KRAB experiment barcode\nAT ratio\nsplit by memory (fold-change based)') + xlab('(A + T) / (A + T + C + G)')
p2 = ggplot(memory_fc[unique,] , aes(x=as.numeric(AT_ratio), colour=memory)) + geom_density() + ggtitle('KRAB experiment barcode\nAT ratio\nsplit by memory (fold-change based)') + xlab('(A + T) / (A + T + C + G)')
grid.arrange(p1, p2)

```
**conclusion:**
AT-richness of the region does not seem to make a difference.

## average LAD probe signal in memory
Maybe the memory effect correlates how strong the lamina association is

```{r average_lad_probe, fig.width=10, fig.height=15}
unique = which(memory_fc$unique_lad_avg_probe)
p1 = ggplot(memory_fc[unique,] , aes(x=memory, y=as.numeric(lad_avg_probe), colour=memory)) + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))+ geom_violin(alpha=0.4) + ggtitle('KRAB experiment barcode\nlamina association\nsplit by memory (fold-change based)') + ylab('average probe signal')
p2 = ggplot(memory_fc[unique,] , aes(x=as.numeric(lad_avg_probe), colour=memory)) + geom_density() + ggtitle('KRAB experiment barcode\nlamina association\nsplit by memory (fold-change based)') + xlab('average probe signal')
grid.arrange(p1, p2)

```
**conclusion:**
Seems that memory barcodes tend to be more lamina associated. Maybe this is also related to replication timing.

## association with very late replicating and high lamina association.

So how much are the observations made for G2 signal correlated to the strength of lamina association

```{r G2_LAD, fig.width=10, fig.height=15}
memory_fc$G2 = '-'
memory_fc$G2[memory_fc$signal_G2>=20] = 'G2'
memory_fc$G2[memory_fc$signal_G2<20] = 'not G2'
unique = which(memory_fc$unique_lad_avg_probe)
p1 = ggplot(memory_fc[unique,] , aes(x=G2, y=as.numeric(lad_avg_probe), colour=G2)) + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))+ geom_violin(alpha=0.4) + ggtitle('KRAB experiment barcode\nlamina association\nsplit by G2 signal of 20') + ylab('average probe signal')
p2 = ggplot(memory_fc[unique,] , aes(x=as.numeric(lad_avg_probe), colour=G2)) + geom_density() + ggtitle('KRAB experiment barcode\nlamina association\nsplit by G2 signal of 20') + xlab('average probe signal')
grid.arrange(p1, p2)

memory_fc$G2 = '-'
memory_fc$G2[memory_fc$signal_G2>=45] = 'G2'
memory_fc$G2[memory_fc$signal_G2<45] = 'not G2'
unique = which(memory_fc$unique_lad_avg_probe)
p1 = ggplot(memory_fc[unique,] , aes(x=G2, y=as.numeric(lad_avg_probe), colour=G2)) + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))+ geom_violin(alpha=0.4) + ggtitle('KRAB experiment barcode\nlamina association\nsplit by G2 signal of 45') + ylab('average probe signal')
p2 = ggplot(memory_fc[unique,] , aes(x=as.numeric(lad_avg_probe), colour=G2)) + geom_density() + ggtitle('KRAB experiment barcode\nlamina association over 50kb\nsplit by G2 signal of 45') + xlab('average probe signal')
grid.arrange(p1, p2)

```

**conclusion:**

There seems to be quite some correlation between the two. The extreme G2 barcodes are mainly also highly associated with the lamina.

## classifying lamina association strength and G2 association.

```{r memory_LAD_G2}
## first let's set a seperation point between highly associated LADs and lower associated LADs
ggplot(memory_fc[unique,] , aes(x=as.numeric(lad_avg_probe))) + geom_density() + ggtitle('KRAB experiment barcode\nlamina association') + xlab('average probe signal')
memory_fc$LAD_strength = '-'
memory_fc$LAD_strength[memory_fc$lad_avg_probe>=0.5] = 'strong LAD'
memory_fc$LAD_strength[memory_fc$lad_avg_probe<0.5] = 'weak LAD'
```
```{r G2_memory, fig.width=10, fig.height=15}
memory_fc$G2 = '-'
memory_fc$G2[memory_fc$signal_G2>=20] = 'G2'
memory_fc$G2[memory_fc$signal_G2<20] = 'not G2'
memory_fc$LAD_G2 = factor(paste(memory_fc$G2, memory_fc$LAD_strength))
tbl = table(memory_fc$LAD_G2)
levels(memory_fc$LAD_G2) = paste(names(tbl), tbl, sep='; n=')

unique = which(memory_fc$unique_lad_avg_probe & memory_fc$unique_signal_G2)
p1 = ggplot(memory_fc[unique,] , aes(x=LAD_G2, y=log2(KRAB_GPvsP_day11 + 0.1), colour=LAD_G2)) + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))+ geom_violin(alpha=0.4) + ggtitle('KRAB experiment barcode\nlamina association split by 0.5\nsplit by G2 signal of 20') + xlab('LAD|G2')
p2 = ggplot(memory_fc[unique,] , aes(x=log2(KRAB_GPvsP_day11 + 0.1), colour=LAD_G2)) + geom_density() + ggtitle('KRAB experiment barcode\nlamina association split by 0.5\nsplit by G2 signal of 20')
grid.arrange(p1, p2)


memory_fc$G2 = '-'
memory_fc$G2[memory_fc$signal_G2>=45] = 'G2'
memory_fc$G2[memory_fc$signal_G2<45] = 'not G2'
memory_fc$LAD_G2 = factor(paste(memory_fc$G2, memory_fc$LAD_strength))
tbl = table(memory_fc$LAD_G2)
levels(memory_fc$LAD_G2) = paste(names(tbl), tbl, sep='; n=')
unique = which(memory_fc$unique_lad_avg_probe & memory_fc$unique_signal_G2)
p1 = ggplot(memory_fc[unique,] , aes(x=LAD_G2, y=log2(KRAB_GPvsP_day11 + 0.1), colour=LAD_G2)) + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))+ geom_violin(alpha=0.4) + ggtitle('KRAB experiment barcode\nlamina association split by 0.5\nsplit by G2 signal of 45') + xlab('LAD|G2')
p2 = ggplot(memory_fc[unique,] , aes(x=log2(KRAB_GPvsP_day11 + 0.1), colour=LAD_G2)) + geom_density() + ggtitle('KRAB experiment barcode\nlamina association split by 0.5\nsplit by G2 signal of 45')
grid.arrange(p1, p2)
```
**conclusion:**

G2 signal seems to have a higher explanitory value, but it might be due to the fact that the 50kb region is to wide of a range. We should check the DamID-seq results of Tom to get an average signal in a smaller region.

## general view on strength of lamina association

I am now also interested in the general relation between lamina association and fold change at day 11.

```{r general_lad_probe}
xy_table = filter_data(fc_table, c('KRAB_GPvsG_day11', 'lad_avg_probe'), poi, day, c('log2','value'), unique_map=T)[[1]]
ggplot(xy_table, aes(x=lad_avg_probe, y=KRAB_GPvsG_day11)) + geom_point(size=0.6, alpha=0.4) + theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10)) + ggtitle('KRAB experiment barcode\naverage lamina association over 50kb\nvs fold change')
```

**conclusion:**

The correlation is there, but I'm not impressed.

## relation of replication timing and chromosome

Maybe chromosome 9 and 13, who showed more memory, just have barcodes that are very late replicating.

```{r memory_chr, fig.width=10, fig.heigth=10}
## let's see the previous plot once more
ggplot(memory_fc[memory_fc$unique_map,] , aes(x=chr_r, fill=memory)) + geom_bar(position='dodge') + ggtitle('KRAB experiment barcode\nchromosomes\nsplit by memory (fold-change based)') + xlab('chromosome')+ theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))


memory_fc$G2 = '-'
memory_fc$G2[memory_fc$signal_G2>=20] = 'G2'
memory_fc$G2[memory_fc$signal_G2<20] = 'not G2'
ggplot(memory_fc[memory_fc$unique_map,] , aes(x=chr_r, fill=G2)) + geom_bar(position='dodge') + ggtitle('KRAB experiment barcode\nchromosome\nsplit by G2 association') + xlab('chromosome')+ theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))

memory_fc$G2 = '-'
memory_fc$G2[memory_fc$signal_G2>=45] = 'G2'
memory_fc$G2[memory_fc$signal_G2<45] = 'not G2'
ggplot(memory_fc[memory_fc$unique_map,] , aes(x=chr_r, fill=G2)) + geom_bar(position='dodge') + ggtitle('KRAB experiment barcode\nchromosome\nsplit by G2 association') + xlab('chromosome')+ theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))

## what about the general picture
xy_table = filter_data(fc_table, c('signal_G2', 'KRAB_GPvsG_day11', 'chr_r', 'lad_avg_probe'), poi, day, c('value','log2', 'factor', 'value'), unique_map=T)[[1]]
xy_table$chr_r = factor(xy_table$chr_r, levels=rownames(chrom_sizes)[1:24])
ggplot(xy_table, aes(x=chr_r,y=KRAB_GPvsG_day11, colour=chr_r)) + labs(x='chromosome', colour='chromosome') + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + geom_violin(alpha=0.4)+ theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))

ggplot(xy_table, aes(x=chr_r,y=signal_G2, colour=chr_r)) + labs(x='chromosome', colour='chromosome') + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + geom_violin(alpha=0.4)+ theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))


# let's look at the general picture of G2 signal vs fold change for 9 and 13 and those of similar size
ggplot(xy_table, aes(x=signal_G2,y=KRAB_GPvsG_day11, colour=chr_r)) + labs(x='G2 signal', colour='chromosome') + geom_point(size=0.6, alpha=0.4) + facet_wrap(~chr_r)

ggplot(xy_table, aes(x=lad_avg_probe,y=KRAB_GPvsG_day11, colour=chr_r)) + labs(x='average lad probe density', colour='chromosome') + geom_point(size=0.6, alpha=0.4) + facet_wrap(~chr_r)
```

**conclusion:**

Chromosome 9 and 13 seem to be relatively late replicating, but there are other chromosomes that mainly have very late replicating barcodes as well. In general there seems to be more memory in chromosome 9 and 13, but while chromose 13 is generally late replicating, this is not the case for chromosome 9.
When looking at the general picture of fold-change compared to memory, the barcodes intergrated in chromosome 9 show a really nice correlation between replication timing and fold change, while for chromosome 13 there seem to be early replicating memory barcodes as well as late-replicating non-memory barcodes. For chromosome 11 and 12, late replicating barcodes seem to have no memory.
I don't think the normalization performed on the G2 signal was influenced by the identity of the chromosome.
There seems to be a chromosome dependent effect on how lamina association and G2 signal influence memory formation, but there is not enough data to really say something conclusive. But the effect of chromosome of intergration is something to keep in mind.


## LAD size and distance to border
maybe the distance to the LAD border, or the size of the LAD are important for memory.

```{r, fig.width=10, fig.heigth=10}

ggplot(memory_fc[which(memory_fc$unique_lad_border_distance==T),] , aes(x=log2(lad_border_distance), colour=memory)) + geom_density(adjust=1/2) + ggtitle('KRAB experiment barcode\ndistance to lad border\nsplit by memory (fold-change based)')
ggplot(memory_fc[which(memory_fc$unique_lad_size==T),] , aes(x=log2(lad_size), colour=memory)) + geom_density(adjust=1/2) + ggtitle('KRAB experiment barcode\nlad size\nsplit by memory (fold-change based)')

memory_fc$G2 = '-'
memory_fc$G2[memory_fc$signal_G2>=20] = 'G2'
memory_fc$G2[memory_fc$signal_G2<20] = 'not G2'
ggplot(memory_fc[which(memory_fc$unique_lad_border_distance==T),] , aes(x=log2(lad_border_distance), colour=G2)) + geom_density(adjust=1/2) + ggtitle('KRAB experiment barcode\ndistance to lad border\nsplit by G2 signal (20)')
ggplot(memory_fc[which(memory_fc$unique_lad_size==T),] , aes(x=log2(lad_size), colour=G2)) + geom_density(adjust=1/2) + ggtitle('KRAB experiment barcode\nlad size\nsplit by G2 signal (20)')

memory_fc$G2 = '-'
memory_fc$G2[memory_fc$signal_G2>=45] = 'G2'
memory_fc$G2[memory_fc$signal_G2<45] = 'not G2'
ggplot(memory_fc[which(memory_fc$unique_lad_border_distance==T),] , aes(x=log2(lad_border_distance), colour=G2)) + geom_density(adjust=1/2) + ggtitle('KRAB experiment barcode\ndistance to lad border\nsplit by G2 signal (45)')
ggplot(memory_fc[which(memory_fc$unique_lad_size==T),] , aes(x=log2(lad_size), colour=G2)) + geom_density(adjust=1/2) + ggtitle('KRAB experiment barcode\nlad size\nsplit by G2 signal (45)')

```
**conclusion:**
The size and of the LAD and the distance to it's border is correlated with memory. But these regions are also mainly replicating in the late G2 fase.


## HiC compartments and memory

Maybe the subcompartments defined by [Rao et al. 2014 cell](http://dx.doi.org/10.1016/j.cell.2014.11.021) are also explanitory. Unfortunately there were only compartment calls for GM12878, but since both K562 and GM12878 orriginate from blood, the main compartment structure is the same.

```{r, fig.width=10, fig.heigth=10}
ggplot(memory_fc[memory_fc$unique_map,] , aes(x=compartment, fill=memory)) + geom_bar(position='dodge') + ggtitle('KRAB experiment barcode\nHiC compartment\nsplit by memory (fold-change based)') + xlab('chromosome')+ theme(axis.text.x = element_text(hjust = 1, angle = 90, size = 10))

xy_table = filter_data(fc_table, c('KRAB_GPvsG_day11', 'compartment', 'lad_2state', 'signal_G2'), poi, day, c('log2','factor', 'factor', 'value'), unique_map=F)[[1]]

ggplot(xy_table, aes(x=compartment, y=KRAB_GPvsG_day11, colour=compartment)) + labs(x='HiC subcompartment', colour='HiC subcompartment') + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + geom_violin(alpha=0.4) + ggtitle('KRAB fold change day 11\nby HiC subcompartment')
ggplot(xy_table[xy_table$lad_2state=='LAD',], aes(x=compartment, y=KRAB_GPvsG_day11, colour=compartment)) + labs(x='HiC subcompartment', colour='HiC subcompartment') + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + geom_violin(alpha=0.4) + ggtitle('KRAB fold change day 11\nby HiC subcompartment\nLAD only')
xy_table$G2 = '-'
xy_table$G2[xy_table$signal_G2>=20] = 'G2'
xy_table$G2[xy_table$signal_G2<20] = 'not G2'
ggplot(xy_table[xy_table$G2=='G2',], aes(x=compartment, y=KRAB_GPvsG_day11, colour=compartment)) + labs(x='HiC subcompartment', colour='HiC subcompartment') + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + geom_violin(alpha=0.4) + ggtitle('KRAB fold change day 11\nby HiC subcompartment\nG2 signal >= 25')

xy_table$G2 = '-'
xy_table$G2[xy_table$signal_G2>=45] = 'G2'
xy_table$G2[xy_table$signal_G2<45] = 'not G2'
ggplot(xy_table[xy_table$G2=='G2',], aes(x=compartment, y=KRAB_GPvsG_day11, colour=compartment)) + labs(x='HiC subcompartment', colour='HiC subcompartment') + geom_point(position=position_jitter(width=0.9), size=0.6, alpha=0.4) + geom_violin(alpha=0.4) + ggtitle('KRAB fold change day 11\nby HiC subcompartment\nG2 signal >= 45')
```

```{r}
sessionInfo()
getwd()
date()
paste("Run time: ",format(Sys.time()-StartTime))
```
