
# knitr document van Steensel lab

# Thethered TRIP
## Christ Leemans, 31-05-2016 - to date 

## Introduction
Laura performed a thetered-TRIP experiment on a K562 cell pool. She transiently transfected the cell pool with GAL4 thetered to 3 different "proteins of interest"(POI), namely G9a, the KRAB domain and CBX5. She took measurements after day 2 to see the initial effect of the thetering and after 12, 11 and 9 days respectively to see if there was any memory of the silencing on day 2. Besides the thetered GAL4-POI, two seperate controlls were taken using unthetered GAL4 and unthethered POI.

## Experimental setup
At this moment Laura has data for 3 different tethering experiments using KRAB, G9a and CBX5. For each protein of interest (POI) there are 12 expression and 12 gDNA files: 3 conditions * 2 different days after induction * 2 replicates. One condition uses an unthethered POI, the second uses only GAL4 and the third condition uses the POI thethered to GAL4 (GAL4-POI). Expression and gDNA data was obtained on day 2 and day 9. With each sequencing run, spikeins were added to normalize across different experiments. There is a different config file to extract the expression values of the spikeins.

## Description of data
For this part of the analysis I used the data that was generated previously in the data preperation report: cl20160713_TRIP_K562_data_preperation. 
The .RData produced contains a large data frame with a row for each barcode and the following columns:

| column name | description |
| ----------- | ----------- |
| CBX_GAL4_exp_2 | expression after thetering GAL4 on day 2  for CBX5 experiment |
| CBX_GAL4_exp_9 | expression after thetering GAL4 on day 9 for CBX5 experiment |
| CBX_GAL4.POI_exp_2 | expression after thetering GAL4-CBX5 on day 2 |
| CBX_GAL4.POI_exp_9 | expression after thetering GAL4-CBX5 on day 9 |
| CBX_POI_exp_2 | expression after thetering CBX5 on day 2 |
| CBX_POI_exp_9 | expression after thetering CBX5 on day 9 |
| G9a_GAL4_exp_12 | expression after thetering GAL4 on day 12 for G9a experiment |
| G9a_GAL4_exp_2 | expression after thetering GAL4 on day 2 for G9a experiment |
| G9a_GAL4.POI_exp_12 | expression after thetering GAL4-G9a on day 12 |
| G9a_GAL4.POI_exp_2 | expression after thetering GAL4-G9a on day 2 |
| G9a_POI_exp_12 | expression after thetering G9a on day 12 |
| G9a_POI_exp_2 | expression after thetering G9a on day 2 |
| KRAB_GAL4_exp_11 | expression after thetering GAL4 on day 11 for KRAB experiment |
| KRAB_GAL4_exp_2 | expression after thetering GAL4 on day 2 for KRAB experiment |
| KRAB_GAL4.POI_exp_11 | expression after thetering GAL4-KRAB on day 11 |
| KRAB_GAL4.POI_exp_2 | expression after thetering GAL4-KRAB on day 2 |
| KRAB_POI_exp_11 | expression after thetering KRAB on day 11 |
| KRAB_POI_exp_2 | expression after thetering KRAB on day 2 |
| CBX_GPvsP_day2 | fold change GAL4-CBX5 vs CBX5 on day 2 |
| CBX_GPvsP_day9 | fold change GAL4-CBX5 vs CBX5 on day 9 |
| G9a_GPvsP_day12 | fold change GAL4-G9a vs G9a on day 12 |
| G9a_GPvsP_day2 | fold change GAL4-G9a vs G9a on day 2 |
| KRAB_GPvsP_day11 | fold change GAL4-KRAB vs KRAB on day 11 |
| KRAB_GPvsP_day2 | fold change GAL4-KRAB vs KRAB on day 2 |
| CBX_GPvsG_day2 | fold change GAL4-CBX5 vs GAL4 on day 2 |
| CBX_GPvsG_day9 | fold change GAL4-CBX5 vs GAL4 on day 9 |
| G9a_GPvsG_day12 | fold change GAL4-G9a vs GAL4 on day 12 |
| G9a_GPvsG_day2 | fold change GAL4-G9a vs GAL4 on day 2 |
| KRAB_GPvsG_day11 | fold change GAL4-KRAB vs GAL4 on day 11 |
| KRAB_GPvsG_day2 | fold change GAL4-KRAB vs GAL4 on day 2 |
| CBX_PvsG_day2 | fold change CBX5 vs GAL4 on day 2 |
| CBX_PvsG_day9 | fold change CBX5 vs GAL4 on day 9 |
| G9a_PvsG_day12 | fold change G9a vs GAL4 on day 12 |
| G9a_PvsG_day2 | fold change G9a vs GAL4 on day 2 |
| KRAB_PvsG_day11 | fold change KRAB vs GAL4 on day 11 |
| KRAB_PvsG_day2 | fold change KRAB vs GAL4 on day 2 |
| G9a_D2_above_norm_cut | all normalization read-counts for G9a > 50 on day 2 |
| G9a_D12_above_norm_cut | all normalization read-counts for G9a > 50 on day 12 |
| CBX_D2_above_norm_cut | all normalization read-counts for CBX5 > 50 on day 2 |
| CBX_D9_above_norm_cut | all normalization read-counts for CBX5 > 50 on day 9 |
| KRAB_D2_above_norm_cut | all normalization read-counts for G9a > 50 on day 2 |
| KRAB_D11_above_norm_cut | all normalization read-counts for G9a > 50 on day 11 |
| chr_f | chromosome of forward mapping read |
| ori_f | orientation of forward mapping read |
| pos_f | location of forward read on the chromosome |
| t_reads_f | total number of forward reads |
| mapq_f | average mapping quality of forward reads mapped to the same location |
| freq1_f | frequency of forward reads mapped to the primary location |
| freq2_f | frequency of forward reads mapped to a possible secondary location |
| chr_r | chromosome of reverse mapping read |
| ori_r | orientation of reverse mapping read |
| pos_r | location of reverse read on the chromosome |
| t_reads_r | total number of reverse reads |
| mapq_r | average mapping quality of reverse reads mapped to the same location |
| freq1_r | frequency of reverse reads mapped to the primary location |
| freq2_r | frequency of reverse reads mapped to a possible secondary location |
| unique_map | according to the thresholds set in the data preperation, is the barcode uniquely mapped |
| rep_family | with which repeat family (repeatmasker nomenclature) does the barcode overlap |
| rep_name | with which repeat name (repeatmasker nomenclature) does the barcode overlap |
| lad | with which state of lamina association does the barcode overlap (constitutive LAD, facultative LAD, faculatative interLAD or constitutive interLAD) |
| chrom | with which of the 12 state chromatin model does the barcode overlap |
| unique_rep_name | does the barcode map to a single repeat name according to the thresholds set |
| unique_rep_family | does the barcode map to a single repeat family according to the thresholds set |
| unique_lad | does the barcode map to a single LAD-state according to the thresholds set |
| unique_chrom | does the barcode map to a single chromatin state according to the thresholds set |



## Path, Libraries, Parameters and Useful Functions

```{r functions}
opts_chunk$set(out.width='750px', dpi=200)
StartTime <-Sys.time()

# 6-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),3,8) 

# libraries:
library(stringr)
library(ggplot2)
library(reshape2)
library(knitr)
library(gridExtra)
library(plyr)
library(grid)


load('../results/TTRIP_K562_FC_exp.rData')

# make cpg distance numeric
fc_table$cpg_distance = as.numeric(fc_table$cpg_distance)

# just so I can sellect the right day for each protein of interest in the loops
days = list(KRAB=c(11,14), G9a=12 ,CBX=c(9,12))


filter_data <- function(fc_table, conditionx, conditiony, poi, day, xtype, ytype, state=NA, unique_map=F){
	# Filter the data for a specific experiment (e.g. GAL4-KRAB vs GAL4 on day 2)
	# Check the data preperation script for a more in depth look on the different
	# selection criteria.
	#
	# Args:
	#   fc_table: the big data-frame with all data.
	#   conditionx: the column name with the classification/expression/fold change that should be on the x-axis
	#   conditiony: the column name with the classification/expression/fold change that should be on the y-axis
	#   poi: the protein of interest in this experiment
	#   day: the day of the experiment
	#   xtype: what is the type of data for the x column?
	#          Used to transform the data correctly [value, factor or log2]
	#   ytype: what is the type of data for the y column?
	#          Used to transform the data correctly [value, factor or log2]
	#   state: optional value to add a state definition as a third column.
	# Returns:
	#   A filtered data frame with an x and y column, the x column contains a factor with
	#   the classification, the y column contains log2 transformed values of the experiment.
	if (!is.na(state)){
		fc_table = fc_table[which(fc_table[,state]!='-'),]
	}
	if (xtype == 'factor'){
		fc_table = fc_table[which(fc_table[,conditionx]!='-'),]
	}
	if (ytype == 'factor'){
		fc_table = fc_table[which(fc_table[,conditiony]!='-'),]
	}
	total = nrow(fc_table)
	# check if the normalization counts are above 50 for each sample
	above_norm = sprintf('%s_D%i_above_norm_cut', poi, day)
	if (length(above_norm)>1){
		fc_table = fc_table[apply(fc_table[,above_norm],1, all),]

	} else{
		fc_table = fc_table[fc_table[,above_norm], ]
	}
	
	summary_table = data.frame(cutoff=rep(NA, 5),
							   removed=rep(0, 5),
							   left=rep(0, 5),
							   stringsAsFactors=F)
	summary_table[1,] = list('above norm-count of 50', 
		                     total - nrow(fc_table),
		                     nrow(fc_table))
	# is the barcode uniquely linked to a single classification for clasifications used
	
	if (!is.na(state)){
		col_names = c('x','y','state')
		cd_matrix = cbind(c(xtype,ytype, 'factor'),c(conditionx,conditiony, state))
	} else {
		col_names = c('x','y')
		cd_matrix = cbind(c(xtype,ytype),c(conditionx,conditiony))
	}
	if (unique_map){
		cd_matrix = rbind(cd_matrix, c('map', 'map'))
	}
	for (i in 1:nrow(cd_matrix)){
		type = cd_matrix[i,1]
		if (type == 'factor'){
			state = cd_matrix[i,2]
			unique_name = paste0('unique_',state)
			fc_table = fc_table[fc_table[,unique_name] | fc_table[,state]=='-',]
		}
		else if(type == 'map'){
			fc_table = fc_table[fc_table[,'unique_map'],]
		}
	}
	summary_table[2, ] = list('unique barcode-state link',
				              summary_table[1,'left'] - nrow(fc_table),
				              nrow(fc_table))

	# check if the log2 expression for the barcode of the GAL4 control > 0
	base_exp = sprintf('%s_GAL4_exp_%s',poi, day)
	above_exp_cut = fc_table[,base_exp]>0
	if (length(base_exp)>1){
		fc_table = fc_table[apply(above_exp_cut,1, all),]
	} else{
		fc_table = fc_table[above_exp_cut, ]
	}
	summary_table[3, ] = list('log2 base expression > 0', 
		                      summary_table[2,'left'] - nrow(fc_table),
	                          nrow(fc_table))
	

	# create a factor column x with the classification
	# the order can be important for the order in which the data is later represented in a plot.
	xy_list = list()
	for (i in 1:nrow(cd_matrix)){
		type = cd_matrix[i,1]
		condition = cd_matrix[i,2]
		if (type == 'factor'){
			if (condition == 'lad'){
				new_values = factor(fc_table[,condition], levels=c('cLAD','fLAD', 'fiLAD', 'ciLAD', '-'))
			} else if(condition=='chrom'){
				chrom_levels = unique(fc_table[,condition])
				chrom_levels = chrom_levels[!is.na(chrom_levels)]
				# sort on the number in the state name
				chrom_levels = chrom_levels[order(sapply(chrom_levels,function(x){
					# if the state is unknown, return a high number so that it ends up at the end of the sort
					if (x!='-'){
						return(as.numeric(str_split(x,'_')[[1]][1]))
					} else{
						return(Inf)
					}}))]
				new_values = factor(fc_table[,condition], levels=chrom_levels)

			} else {
				new_values = factor(fc_table[,condition])
			}
			
		} else if (type=='log2'){

			new_values = log2(fc_table[,condition] + 0.1)
		} else if (type != 'map'){
	    	new_values = fc_table[,condition]
		}
		if (type != 'map'){
			xy_list[[i]] = new_values
		}
	}
	xy_table=data.frame(xy_list)
	colnames(xy_table) = col_names
	rownames(xy_table) = rownames(fc_table)
	xy_table = data.frame(xy_table)
	xy_table = xy_table[!is.na(xy_table$x), ]
	xy_table = xy_table[!is.na(xy_table$y), ]
	summary_table[4, ] = list('not NA', 
		                      summary_table[3,'left'] - nrow(xy_table),
	                          nrow(xy_table))

	xy_table = xy_table[!is.infinite(xy_table$x), ]
	xy_table = xy_table[!is.infinite(xy_table$y), ]
	summary_table[5, ] = list('not infinite', 
		                      summary_table[4,'left'] - nrow(xy_table),
	                          nrow(xy_table))
	return(list(xy_table, summary_table))
}

plot_values <- function(xy_table, xlab, ylab, bc_vec = c(), which_state=NA, text_size=20){
	# function to plot log2 expression or fold changes in column y against classifications in column x
	# coloured by x
	# Args:
	#   xy_table: table with filtered x and y values
	#   xlab: label on x-axis
	#   ylab: label on y-axis
	#   bc_vec: vector for plotting a subset of barcodes as points (boxplot still uses complete range)
	#   which_state: optional value to plot the expression for a single state
	#   text_size: size of the text on the axis
	# Return:
	#   ggplot object with plot
	if (!is.na(which_state)){
		xy_table = xy_table[xy_table$x == which_state, ]
	}
	if (length(bc_vec)>0){
		subset = xy_table[bc_vec,]
		points = geom_point(data=subset,aes(y=y), shape=19, size =0.9, position=position_jitter(width=.2))
	} else {
		points = geom_point(shape=19, size =0.9, position=position_jitter(width=.2))
	}
	ggplot(xy_table,aes(x = x, y=y, colour=x)) +
		theme(panel.background = element_rect(fill = "lavender")) +
		theme(strip.text.x = element_text(size = 28)) + geom_boxplot( outlier.colour=NA) +
		points +
		stat_summary(fun.y=median, aes(ymin=..y.., ymax=..y..), geom='errorbar', width=0.3, color='black', size=1.25) +
		theme(legend.position="none") +
		theme(axis.title = element_text(size = 20, face='bold')) +
		theme(axis.text.x = element_text(hjust = 1, angle = 90)) +
		theme(axis.text = element_text(size = text_size)) +
		geom_hline(yintercept=0, colour = "grey30") +
		theme(plot.title = element_text(size=38))+
		ylab(ylab) + xlab(xlab)
}

correlate <- function(xy_table, title, day1, day2){
	fit = lm(xy_table$y ~ xy_table$x)
	coef = summary(fit)$coefficients
	spearman = cor.test(xy_table$x, xy_table$y, method='spearman')
	pearson = cor.test(xy_table$x, xy_table$y, method='pearson')
	test_text = sprintf("    Spearman's rank correlation rho
 data:  day %.0f and day %.0f
 S = %.0f, p-value = %0.4f
 alternative hypothesis: 
 true rho is not equal to 0
 sample estimates:
       rho 
 %0.7f 
 
    Pearson's product-moment correlation
 data:  day %.0f and day %.0f
 t = %.04f, df = %.0f, p-value = %0.4f
 alternative hypothesis: 
 true correlation is not equal to 0
 95 percent confidence interval:
  %0.8f  %0.8f
 sample estimates:
       cor 
 %0.7f ", day1, day2, spearman$statistic, spearman$p.value, spearman$estimate,
 day1, day2, pearson$statistic, pearson$parameter, pearson$p.value, pearson$conf.int[1],
 pearson$conf.int[2], pearson$estimate)
	test_table = tableGrob(rbind(title,test_text),rows=NULL, theme=ttheme_default(core=list(fg_params=list(fontsize=c(12,10), fontface=c(2L,1L)))))
	spearman_p = spearman$p.value
	pearson_p = pearson$p.value

	label = sprintf('y = %0.3f + %0.3fx\nn=%i; P=%0.3f; S=%0.3f',  coef[1,'Estimate'], coef[2,'Estimate'], nrow(xy_table), pearson_p, spearman_p)
	return(list(test_table, label))
}

plot_2vs9 <- function(xy_table, xlab, ylab, day1, day2, y_lim = ylim(-7.5,2.5), x_lim=xlim(-10,2), nCol=NULL, label_size=20, text_size=10){
	# function to plot fold change of day 2 against fold change after day 9, 11 or12
	# seperated by state
	# Args:
	#   xy_table: table with filtered x and y values and a state linked to each barcode
	#   title: title of the plot
	#   xlab: label on x-axis
	#   ylab: label on y-axis
	#   mem_day: day of the memory experiment (e.g. 9)
	#   text_size: size of the text on the axis
	# Return:
	#   ggplot object with plot and list of ggplot objects with pearon and spearman results
	state_vec = names(which(table(xy_table$state)>1))
	grob_list = list()
	fit_table = data.frame(state=state_vec, x=Inf, y=Inf, label=NA)
	for (state in state_vec){
		this_xy = xy_table[which(xy_table$state==state), ]
		if (nrow(this_xy)>3){
			test = correlate(this_xy, state, day1, day2)
			grob_list[[state]] = test[[1]]
			fit_table[fit_table$state==state,'label'] = test[[2]]
		}
	}
	
	aes = aes(x = x, y=y, colour=state)
	cat('\n\n')
	g = ggplot(xy_table, aes) +
		theme(panel.background = element_rect(fill = "lavender"))+
		theme(strip.text.x = element_text(size = 10)) +
		geom_point(shape=19, size =0.9, position=position_jitter(width=.2))  +
		theme(legend.position="none") +
		theme(axis.text.x = element_text(hjust = 1, angle = 90)) +
		theme(axis.title = element_text(size=label_size)) +
		theme(text = element_text(size = text_size)) +
		geom_hline(yintercept=0, colour = "grey30") +
		geom_text(aes(x=x,y=y,label=label), data=fit_table, vjust=1, hjust=1, size=5) +
		ggtitle('P=Pearson; S=Spearman') + y_lim + x_lim +
		ylab(ylab) + xlab(xlab) + stat_smooth(method = "lm") + facet_wrap(~ state, ncol=nCol)
	return(list(g, grob_list))
}

plot_wilcox <- function(xy_table, state, poi, day, title, xlab, ylab="log2 (fold change)", text_size=20, p_cut=0.05){
	# function to perform wilcoxon tests for a certain state (e.g. cLADs), and if significant,
	# display the results and plot the log2 fold change that state against the values of the
	# other states.
	# Args:
	#   xy_table: table with filtered x and y values and a state linked to each barcode
	#   title: title of the plot
	#   xlab: label on x-axis
	#   ylab: label on y-axis
	#   text_size: size of the text on the axis
	# Return:
	#   ggplot object with plot and ggplot object with outcome of Wilcoxon-test statistiscs
	if (length(which(xy_table$x==state)) > 0){
		wc = wilcox.test(xy_table$y[xy_table$x==state],xy_table$y[xy_table$x!=state], conf.int=T)
		wc$data.name = sprintf('%s day%i %s vs NOT %s', poi, day, state, state)
		nlevels = length(levels(xy_table$x))
		p.value = p.adjust(wc$p, n = nlevels)
		if (wc$p.value < p_cut){
			notx = paste('NOT', state)
			xy_table$this_x[xy_table$x==state] = state
			xy_table$this_x[xy_table$x!=state] = notx
			xy_table$this_x = factor(xy_table$this_x, levels=c(state,notx))
			t = textGrob(sprintf('        Wilcoxon rank sum test with continuity correction\nadjusted p-value threshold:\n%.2g\ndata:%s day%i %s vs NOT %s\nW = %i, p-value = %0.5f\n alternative hypothesis: true location shift is not equal to 0\n95 percent confidence interval:\n %0.8f %0.8f\nsample estimates:\ndifference in location\n%0.7f',  p_cut, poi, day, state, state, wc$statistic, p.value, wc$conf.int[1], wc$conf.int[2], wc$estimate))
			p = ggplot(xy_table,aes(x = this_x, y=y, colour=state)) +
				theme(panel.background = element_rect(fill = "lavender")) +
				theme(strip.text.x = element_text(size = 28)) + geom_boxplot(aes(colour=factor(this_x)), outlier.colour=NA) +
				geom_point(shape=19, position=position_jitter(width=.2))  + ggtitle(title) +
				stat_summary(fun.y=median, aes(ymin=..y.., ymax=..y..), geom='errorbar', width=0.3, color='black', size=1.25) +
				theme(legend.position="none") +
				theme(axis.title = element_text(size = 28)) +
				theme(axis.text.x = element_text(hjust = 1, angle = 90)) +
				theme(axis.text = element_text(size = text_size)) +
				geom_hline(yintercept=0, colour = "grey30") +
				theme(plot.title = element_text(size=24)) +
				ylab(ylab) + xlab(xlab)
			return(list(p,t))
		} else{
			return(NA)
		}
	} else {
		return(NA)
	}
	
}

```

## Create plots
We can make an easy loop function to first create all plots for each classification and POI.


```{r create_plots_main, cache=F}
categorical = c('lad', 'chrom', 'rep_name', 'rep_family', 'rep_class')
discrete = c('cpg_distance', 'timing')
empty_list = list()
for (class in c(categorical, discrete)){
	empty_list[[class]] = list()
}
# lists within lists to store the data
plots_2 = plots_9 = plots_exp = plots_2vs9 = plots_expVs9 = stats_2 = stats_9 = stats_exp = corr_2vs9 = stats_2vs9 = corr_expVs9 = stats_expVs9 = empty_list

empty_list = list()
for (class in categorical){
	empty_list[[class]] = list()
}
plots_wilcox_2 = plots_wilcox_9 = empty_list

class_vec = c('lad', 'chrom', 'rep_class')
for (poi in c('KRAB', 'G9a', 'CBX')){
	for (class in class_vec){
		# for different classes use descriptive x-axis labels
		# and if there is a lot of different classes, use a smaller font 
		if (class=='rep_family'){
			text_size=10
			xlab = 'repeat family'
			if (poi == 'KRAB'){
				ncol = 5
			} else {
				ncol = 4
			}
			xtype = 'factor'
			
		} else if(class=='lad'){
			xlab = 'LAD-state'
			text_size = 20
			ncol = 2
			xtype = 'factor'
		} else if(class=='chrom'){
			xlab = 'Chromatin state'
			text_size = 20
			ncol = 3
			xtype = 'factor'
		}else if(class=='cpg_distance'){
			xlab = 'distance to nearest cpg'
			text_size = 20
			ncol = 3
			xtype = 'value'
		}else if(class=='rep_class'){
			xlab = 'repeat class'
			text_size = 20
			ncol = 3
			xtype = 'factor'
		}
		# the column name of the fold-change on day 2
		condition_2 = paste0(poi, '_GPvsG_day2')
		# filter the data and get table with x and y values and a statistics table
		# x and y value table:
		# 	x: a factor of the classification
		# 	y: the log2 transformed fold changes
		# statistics table:
		#	for each selection criteria how many barcodes were kicked out and how many were left.
		fc_2 = filter_data(fc_table, class,  condition_2, poi, 2, xtype, 'log2')
		xy_table_2= fc_2[[1]]
		# create a grob for plotting the statistics and a plot for the fold-changes
		stats_2[[class]][[poi]] = tableGrob(fc_2[[2]], rows=NULL)
		plots_2[[class]][[poi]] = plot_values(xy_table_2, xlab, 'log2(fold change)', 
			                                  text_size=text_size)
		fc_9 = list()
		condition_9 = list()
		# do the same for later day
		stats_9[[class]][[poi]] = list()
		plots_9[[class]][[poi]] = list()
		for (day in days[[poi]]){
			d = as.character(day)
			condition_9[[d]] = sprintf('%s_GPvsG_day%i',poi,day)

			fc_9[[d]] = filter_data(fc_table, class,  condition_9[[d]], poi, day, xtype, 'log2')
			xy_table_9 = fc_9[[d]][[1]]
			stats_9[[class]][[poi]][[d]] = tableGrob(fc_9[[d]][[2]], rows=NULL)
			plots_9[[class]][[poi]][[d]] = plot_values(xy_table_9, xlab, 
				   									   'log2(fold change)', 
				                                       text_size=text_size)

		}
		
		# and for the expression at day 2
		condition_exp = paste0(poi,'_GAL4_exp_2')
		fc = filter_data(fc_table, class, condition_exp, poi, 2, xtype, 'log2')
		xy_table = fc[[1]]
		
		stats_exp[[class]][[poi]] = tableGrob(fc[[2]], rows=NULL)
		plots_exp[[class]][[poi]] = plot_values(xy_table, xlab, 'log2(expression)', 
			                                      text_size=text_size)

		if (class %in% categorical){
			plots_wilcox_2[[class]][[poi]] = list()
			plots_wilcox_9[[class]][[poi]] = list()
			# and now the wilcoxon tests for each state in a class
			for (state in unique(fc_table[,class])){
				wc=plot_wilcox(fc_2[[1]], state, poi, 2,  xlab, sprintf("fold change day %i\n%s",2,poi), 'log2(fold-change)')
				if (any(!is.na(wc))){
					plots_wilcox_2[[class]][[poi]][[state]] = wc
				}
			}
			for (day in days[[poi]]){
				d = as.character(day)
				plots_wilcox_9[[class]][[poi]][[d]] = list()
				for (state in unique(fc_table[,class])){
					wc=plot_wilcox(fc_9[[d]][[1]], state, poi, day,  xlab, sprintf("fold change day%i\n%s",day,poi), 'log2(fold-change)')
					if (any(!is.na(wc))){
						plots_wilcox_9[[class]][[poi]][[d]][[state]] = wc
					}
				}
			}
		}
		

		stats_expVs9[[class]][[poi]] = list()
		plots_expVs9[[class]][[poi]] = list()
		corr_expVs9[[class]][[poi]] = list()
		stats_2vs9[[class]][[poi]] = list()
		plots_2vs9[[class]][[poi]] = list()
		corr_2vs9[[class]][[poi]] = list()
		lim_exp = xlim(min(xy_table$y), max(xy_table$y))
		lim_2 = xlim(min(xy_table_2$y), max(xy_table_2$y))
		for (day in days[[poi]]){
			d = as.character(day)
			# and plots of base expression vs fold change on day 9
			fc_expVs9 = filter_data(fc_table, condition_exp,  condition_9[[d]], poi, day, 'log2', 'log2', class)
			xy_table = fc_expVs9[[1]]
			stats_expVs9[[class]][[poi]][[d]] = tableGrob(fc_expVs9[[2]], rows=NULL)
			p = plot_2vs9(xy_table, 'log2(expression)', 'log2(fold change)', 2,
				          day, x_lim=lim_exp, nCol=ncol, text_size=text_size)
			plots_expVs9[[class]][[poi]][[d]] = p[[1]]
			
			corr_expVs9[[class]][[poi]][[d]] = p[[2]]

			# and plots of fold change on day 2 vs day 9
			fc_2vs9 = filter_data(fc_table, condition_2,  condition_9[[d]], poi, day, 'log2', 'log2', class)
			xy_table = fc_2vs9[[1]]
			stats_2vs9[[class]][[poi]][[d]] = tableGrob(fc_2vs9[[2]], rows=NULL)
			p = plot_2vs9(xy_table, 'log2(fold change)', 'log2(fold change)', 2,
				          day,x_lim = lim_2, nCol=ncol, text_size=text_size)
			plots_2vs9[[class]][[poi]][[d]] = p[[1]]
			
			corr_2vs9[[class]][[poi]][[d]] = p[[2]]
		}

	}
	
}

```
```{r save_plots, echo=F}

save(plots_2, plots_9, plots_exp, plots_wilcox_2, plots_wilcox_9, plots_2vs9, plots_expVs9, stats_2, stats_9, stats_exp, corr_2vs9, stats_2vs9, corr_expVs9, stats_expVs9, file = 'plots.rData')

```
## comparison between two later days
We now have two timepoints for KRAB and CBX after the initial plasmid has been lost
Let's see how they differ.

## expression
```{r memory, fig.width=10, fig.height=15}
KRAB_14_1 = 'KRAB_GAL4.POI_exp_D14_r1'
KRAB_14_2 = 'KRAB_GAL4.POI_exp_D14_r2'
fc = filter_data(fc_table, KRAB_14_1,  KRAB_14_2, 'KRAB', 14, 'log2', 'log2', unique_map=T)
test=correlate(fc[[1]], 'KRAB expression GAL4_POI\n day 14 replicates', 14, 14)
top=data.frame(x=Inf, y=Inf, label=test[[2]])
p = ggplot(fc[[1]],aes(x=x, y=y)) + geom_point() +xlab(KRAB_14_1)+ylab(KRAB_14_2) + geom_text(aes(label=label), data=top, vjust=1, hjust=1, size=5) + stat_smooth(method = "lm")
grid.arrange(test[[1]], p, ncol=1, heights=c(3,7))

KRAB_11_1 = 'KRAB_GAL4.POI_exp_D11_r1'
KRAB_11_2 = 'KRAB_GAL4.POI_exp_D11_r2'
fc = filter_data(fc_table, KRAB_11_1,  KRAB_11_2, 'KRAB', 11, 'log2', 'log2', unique_map=T)
test=correlate(fc[[1]], 'KRAB expression GAL4_POI\n day 11 replicates', 11, 11)
top=data.frame(x=Inf, y=Inf, label=test[[2]])
p = ggplot(fc[[1]],aes(x=x, y=y)) + geom_point() +xlab(KRAB_11_1)+ylab(KRAB_11_2) + geom_text(aes(label=label), data=top, vjust=1, hjust=1, size=5) + stat_smooth(method = "lm")
grid.arrange(test[[1]], p, ncol=1, heights=c(3,7))

KRAB_14_1 = 'KRAB_GAL4_exp_D14_r1'
KRAB_14_2 = 'KRAB_GAL4_exp_D14_r2'
fc = filter_data(fc_table, KRAB_14_1,  KRAB_14_2, 'KRAB', 14, 'log2', 'log2', unique_map=T)
test=correlate(fc[[1]], 'KRAB expression GAL4-only\n day 14 replicates', 14, 14)
top=data.frame(x=Inf, y=Inf, label=test[[2]])
p = ggplot(fc[[1]],aes(x=x, y=y)) + geom_point() +xlab(KRAB_14_1)+ylab(KRAB_14_2) + geom_text(aes(label=label), data=top, vjust=1, hjust=1, size=5) + stat_smooth(method = "lm")
grid.arrange(test[[1]], p, ncol=1, heights=c(3,7))

KRAB_11 = 'KRAB_GAL4.POI_exp_11'
KRAB_14 = 'KRAB_GAL4.POI_exp_14'
fc = filter_data(fc_table, KRAB_11,  KRAB_14, 'KRAB', 11, 'log2', 'log2', unique_map=T)
test=correlate(fc[[1]], 'KRAB expression\nday 11 vs 14', 11, 14)
top=data.frame(x=Inf, y=Inf, label=test[[2]])
p = ggplot(fc[[1]],aes(x=x, y=y)) + geom_point() +xlab(KRAB_11)+ylab(KRAB_14) + geom_text(aes(label=label), data=top, vjust=1, hjust=1, size=5) + stat_smooth(method = "lm")
grid.arrange(test[[1]], p, ncol=1, heights=c(3,7))

KRAB_11 = 'KRAB_GPvsG_day11'
KRAB_14 = 'KRAB_GPvsG_day14'
fc = filter_data(fc_table, KRAB_11,  KRAB_14, 'KRAB', 11, 'log2', 'log2', unique_map=T)
test=correlate(fc[[1]], 'KRAB log2(fold-change)\nday 11 vs 14', 11, 14)
top=data.frame(x=Inf, y=Inf, label=test[[2]])
p = ggplot(fc[[1]],aes(x=x, y=y)) + geom_point() +xlab(KRAB_11)+ylab(KRAB_14) + geom_text(aes(label=label), data=top, vjust=1, hjust=1, size=5) + stat_smooth(method = "lm")
grid.arrange(test[[1]], p, ncol=1, heights=c(3,7))

CBX_9 = 'CBX_GAL4.POI_exp_9'
CBX_12 = 'CBX_GAL4.POI_exp_12'
fc = filter_data(fc_table, CBX_9,  CBX_12, 'CBX', 9, 'log2', 'log2', unique_map=T)
test=correlate(fc[[1]], 'CBX expression\nday 9 vs 14', 9, 12)
top=data.frame(x=Inf, y=Inf, label=test[[2]])
p = ggplot(fc[[1]],aes(x=x, y=y)) + geom_point() +xlab(CBX_9)+ylab(CBX_12) + geom_text(aes(label=label), data=top, vjust=1, hjust=1, size=5) + stat_smooth(method = "lm")
grid.arrange(test[[1]], p, ncol=1, heights=c(3,7))

CBX_9 = 'CBX_GPvsG_day9'
CBX_12 = 'CBX_GPvsG_day12'
fc = filter_data(fc_table, CBX_9,  CBX_12, 'CBX', 9, 'log2', 'log2', unique_map=T)
test=correlate(fc[[1]], 'CBX log2(fold-change)\nday 9 vs 12', 9, 12)
top=data.frame(x=Inf, y=Inf, label=test[[2]])
p = ggplot(fc[[1]],aes(x=x, y=y)) + geom_point() +xlab(CBX_9)+ylab(CBX_12) + geom_text(aes(label=label), data=top, vjust=1, hjust=1, size=5) + stat_smooth(method = "lm")
grid.arrange(test[[1]], p, ncol=1, heights=c(3,7))
```

## repeat family's
Repeats can be classified using a tree made up of class, family and name. Repeatmasker can link DNA regions to either of those levels. If there is doubt wether an annotation is made correctly, a "?" is added to the level.

### base expression level
First let's look if there are differences in basal expression levels of the intergrations in different repeat families.
For this we can look at the GAL4 control.

```{r rep_base_exp, fig.width=10, fig.height=15, eval=T}
rep_plots = plots_exp[['rep_family']]
rep_stats = stats_exp[['rep_family']]
for (poi in names(rep_plots)){
	title = sprintf("log2(expression) of GAL4 per repeat family\nday 2 in the %s-experiment",poi)
	
	grid.arrange(rep_stats[[poi]], rep_plots[[poi]],
		         top=textGrob(title, gp=gpar(fontsize=30, face='bold')), heights=c(1,6))
}
```
**conclusion:**

Some of the LINE/L1 elements seem to be more lowly expressed, but this could be just because their are more data-points.

### fold-change on day 2
First let's at the fold changes between GAL4-POI and GAL4 between different repeat families.
The first plot shows the overall fold changes per repeat family. 
After this plot, wilcoxon test results are shown for those families for which the p-value is below an adjusted threshold.
This adjustment is done simply by dividing 0.05 by the number of distinct families.

```{r rep_fc_2, fig.width=10, fig.height=15, eval=T}
rep_plots = plots_2[['rep_family']]
rep_stats = stats_2[['rep_family']]
for (poi in names(rep_plots)){
	title = sprintf("fold change day %i\n%s",2,poi)
	grid.arrange(rep_stats[[poi]], rep_plots[[poi]],
		         top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,6))
}
rep_plots = plots_wilcox_2[['rep_family']]
for (poi in names(rep_plots)){
	title = sprintf("fold change day %i %s",2,poi)
	for (state in names(rep_plots[[poi]])){
		wc = rep_plots[[poi]][[state]]
		grid.arrange(wc[[2]], wc[[1]],
			         top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,3))
	}
}
```
**conclusion:**

On day 2 the rRNA integrations seem not to be affected by GAL4-POI.  
This could be because it is transcribed by a different polymerase or because the protein construct is not able to localize to the intergration site. But maybe then the rate of transcription would be different.


```{r rRNA, fig.width=10, fig.height=10, eval=T}
## let´s double check the base expression of the rRNA intergrations that show no effect of KRAB thetering
plots = list()
cut_off = c(KRAB=-2, G9a=0, CBX=-3)
for (poi in c('KRAB', 'G9a', 'CBX')){
	above_rRNA = rownames(fc_table)[which(log2(fc_table[,paste0(poi,'_GPvsG_day2')])>-2&fc_table$rep_class=='rRNA')]
	condition = paste0(poi,'_GAL4_exp_2')
	fc = filter_data(fc_table, 'rep_class', condition, poi, 2, 'factor', 'log2')
	xy_table = fc[[1]]
    plots[[poi]] = plot_values(xy_table, "repeat family", "log2(expression)",bc_vec=above_rRNA, which_state='rRNA') + ggtitle(paste0("expression\nwith GAL4\nday 2 ",poi))
}
do.call(grid.arrange,c(plots, nrow=1))

```


### fold-change on day 9, 11 and 12
Now let's look at the fold changes between GAL4-POI and GAL4 between different repeat families in the memory setting.
The first plot again shows the overall fold changes per repeat family. 
After this plot, wilcoxon test results are shown for those families for which the p-value is below an adjusted threshold.
This adjustment is done simply by dividing 0.05 by the number of distinct families.


```{r rep_fc_9, fig.width=10, fig.height=15, eval=T}
rep_plots = plots_9[['rep_family']]
rep_stats = stats_9[['rep_family']]
for (poi in names(rep_plots)){
	for (day in names(rep_plots[[poi]])){
		title = sprintf("fold change day %s\n%s",day,poi)
		grid.arrange(rep_stats[[poi]][[day]], rep_plots[[poi]][[day]],
		         top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,6))
	}
	
}
rep_plots = plots_wilcox_9[['rep_family']]
for (poi in names(rep_plots)){
	for (day in names(rep_plots[[poi]])){
		for (state in names(rep_plots[[poi]][[day]])){
			wc = rep_plots[[poi]][[day]][[state]]
		
			title = sprintf("fold change day %s %s",day,poi)
			grid.arrange(wc[[2]], wc[[1]],
			         	 top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,3))
		}
	}
}
```
**conclusion:**

There does not seem to be a repetitive element in which integrations specifically show a memory effect.


### correlation between expression on day 2 and fold change on day 9, 11 or 12
It could very well be that the amount of expression on day 2 is correlated with the occurence of memory.
It could be harder to keep the repressive state when there is a lot of signals to stimulate transcription.

```{r rep_Expvs9, fig.width=10, fig.height=25, eval=T}
rep_plots = plots_expVs9[['rep_family']]
rep_stats = stats_expVs9[['rep_family']]
rep_corr = corr_expVs9[['rep_family']]
for (poi in names(rep_plots)){
	for (day in names(rep_plots[[poi]])){
		title = sprintf("fold change day 2 vs day %s\n%s",day, poi)
		
		do.call(grid.arrange, c(rep_corr[[poi]][[day]], ncol=3, top=list(textGrob(title, gp=gpar(fontsize=38)))))

		grid.arrange(rep_stats[[poi]][[day]], rep_plots[[poi]][[day]], top=list(textGrob(title, gp=gpar(fontsize=38))), heights=c(1,8))
	}
}
```



### correlation between fold-change on day 2 and day 9,11 or 12
It would be interesting to see if integrations that showed a big effect on day 2, 
still show more difference in the memory setting, or that initial effect-size has
no impact on memory formation.


```{r rep_2vs9, fig.width=10, fig.height=25, eval=T}
rep_plots = plots_2vs9[['rep_family']]
rep_stats = stats_2vs9[['rep_family']]
rep_corr = corr_2vs9[['rep_family']]
for (poi in names(rep_plots)){
	for (day in names(rep_plots[[poi]])){
		title = sprintf("fold change day 2 vs day %s\n%s",day, poi)
		
		do.call(grid.arrange, c(rep_corr[[poi]][[day]], ncol=3, top=list(textGrob(title, gp=gpar(fontsize=38)))))

		grid.arrange(rep_stats[[poi]][[day]], rep_plots[[poi]][[day]], top=list(textGrob(title, gp=gpar(fontsize=38))), heights=c(1,8))
	}
}
```

## LAD states
I defined 4 different LAD-states, being constitutive LADs (cLAD), fLADs, lamina-associated in K562 (K562-fLAD), fLADS, not lamina associated in K562 (other-fLAD) and constitutive interLADs (ciLAD). We expect intergrations that are found in LADs to be more lowly expressed than intergrations in interLADs. Since G9a methylation is linked to lamina association, it would be interesting to see if the the difference in effect of G9a between LADs and iLADs is more profound than the difference in effect of KRAB and CBX5.

### base expression level
First let's look if there are differences in basal expression levels of the intergrations in different LAD states.
For this we can look at the GAL4 control.


```{r lad_exp, fig.width=10, fig.height=15, eval=T}
lad_plots = plots_exp[['lad']]
lad_stats = stats_exp[['lad']]
for (poi in names(lad_plots)){
	title = sprintf("log2(expression) of GAL4 per LAD state\nday 2 in the %s-experiment",poi)
	grid.arrange(lad_stats[[poi]], lad_plots[[poi]],
		         top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,6))
}
```
**conclusion:**

Although the expression in the two lamina-associated states is lower than the states that are
not associated with the lamina, this difference is not that big. This is probably due to the fact
that the promotor is relatively strong.



### fold-change on day 2
First let's at the fold changes between GAL4-POI and GAL4 between different LAD-states.
The first plot shows the overall fold changes per LAD-state. 
After this plot, wilcoxon test results are shown for those families for which the p-value is below an adjusted threshold.
This adjustment is done simply by dividing 0.05 by the number of distinct states.

```{r lad_fc2, fig.width=10, fig.height=15, eval=T}
lad_plots = plots_2[['lad']]
lad_stats = stats_2[['lad']]
for (poi in names(lad_plots)){
	title = sprintf("fold change day %i\n%s",2,poi)
	grid.arrange(lad_stats[[poi]], lad_plots[[poi]],
		         top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,6))
}
lad_plots = plots_wilcox_2[['lad']]
for (poi in names(lad_plots)){
	title = sprintf("fold change day %i %s",days[poi],poi)
	for (state in names(lad_plots[[poi]])){
		wc = lad_plots[[poi]][[state]]
		grid.arrange(wc[[2]], wc[[1]],
			         top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,3))
	}
}
```
**conclusion:**

The effect of the thetered proteins seem to be slightly larger for lamina-associated states.


### fold-change on day 9, 11 and 12
Now let's look at the fold changes between GAL4-POI and GAL4 between different LAD state in the memory setting.
The first plot again shows the overall fold changes per LAD state. 
After this plot, wilcoxon test results are shown for those families for which the p-value is below an adjusted threshold.
This adjustment is done simply by dividing 0.05 by the number of distinct families.



```{r lad_fc9, fig.width=10, fig.height=15, eval=T}
lad_plots = plots_9[['lad']]
lad_stats = stats_9[['lad']]
for (poi in names(lad_plots)){
	for (day in names(lad_plots[[poi]])){
		title = sprintf("fold change day %s\n%s",day,poi)
		grid.arrange(lad_stats[[poi]][[day]], lad_plots[[poi]][[day]],
		        	 top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,6))
	}
	
}
lad_plots = plots_wilcox_9[['lad']]
for (poi in names(lad_plots)){
	for (day in names(lad_plots[[poi]])){
		for (state in names(lad_plots[[poi]][[day]])){
			title = sprintf("fold change day %s %s",day,poi)
			wc = lad_plots[[poi]][[day]][[state]]
			grid.arrange(wc[[2]], wc[[1]],
			        	 top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,3))
		}
		
	}
}
```
**conclusion:**

There seems to be slightly more memory in lamina-associated states. Also the difference between
lamina-associated states and not lamina-associated domains seem to have gotten larger.

### correlation between expression on day 2 and fold change on day 9, 11 or 12
It could very well be that the amount of expression on day 2 is correlated with the occurence of memory.
It could be harder to keep the repressive state when there is a lot of signals to stimulate transcription.

```{r lad_expvs9, fig.width=10, fig.height=15, eval=T}
lad_plots = plots_expVs9[['lad']]
lad_stats = stats_expVs9[['lad']]
lad_corr = corr_expVs9[['lad']]
for (poi in names(lad_plots)){
	for (day in names(lad_plots[[poi]])){
		title = sprintf("fold change day 2 vs day %s\n%s",day, poi)
		
		do.call(grid.arrange, c(lad_corr[[poi]][[day]], ncol=3, top=list(textGrob(title, gp=gpar(fontsize=38)))))

		grid.arrange(lad_stats[[poi]][[day]], lad_plots[[poi]][[day]], top=list(textGrob(title, gp=gpar(fontsize=38))), heights=c(1,8))
	}
}
```

### correlation between fold change on day 2 and day 9, 11 or 12
It could very well be that the amount of suppression on day 2 is correlated with the occurence of memory.
If it is harder for the transcription machinery to access the site on day 2, this could mean that the suppressive
chromatin state is more stable and more likely to be maintained.


```{r lad_2vs9, fig.width=10, fig.height=15, eval=T}
lad_plots = plots_2vs9[['lad']]
lad_stats = stats_2vs9[['lad']]
lad_corr = corr_2vs9[['lad']]
for (poi in names(lad_plots)){
	for (day in names(lad_plots[[poi]])){
		title = sprintf("fold change day 2 vs day %s\n%s",day, poi)
		
		do.call(grid.arrange, c(lad_corr[[poi]][[day]], ncol=3, top=list(textGrob(title, gp=gpar(fontsize=38)))))

		grid.arrange(lad_stats[[poi]][[day]], lad_plots[[poi]][[day]], top=list(textGrob(title, gp=gpar(fontsize=38))), heights=c(1,8))
	}
}
```

## Chromatin states
I used a 15-state model from the chromatin state Encode track in UCSC. ChIP-seq data from the Broad Histone track was used to generate this track. Data for nine factors plus input and nine cell types was binarized separately at a 200 base pair resolution based on a Poisson background model. The chromatin states were learned from this binarized data using a multivariate Hidden Markov Model (HMM) that explicitly models the combinatorial patterns of observed modifications (Ernst and Kellis, 2010). To learn a common set of states across the nine cell types, first the genomes were concatenated across the cell types. For each of the nine cell types, each 200 base pair interval was then assigned to its most likely state under the model. Detailed information about the model parameters and state enrichments can be found in (Ernst et al, accepted). 

### base expression level
First let's look if there are differences in basal expression levels of the intergrations in different chromatin states.
For this we can look at the GAL4 control.

```{r, fig.width=10, fig.height=15, eval=T}
chrom_plots = plots_exp[['chrom']]
chrom_stats = stats_exp[['chrom']]
for (poi in names(chrom_plots)){
	title = sprintf("log2(expression) of GAL4 per Chromatin state\nday 2 in the %s-experiment",poi)
	grid.arrange(chrom_stats[[poi]], chrom_plots[[poi]],
		         top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,6))
}
```
**Conclustion:**

In genereral there does not seem to be a lot of variation in expression level except for maybe state 13.



### fold-change on day 2
First let's at the fold changes between GAL4-POI and GAL4 between different Chromatin-states.
The first plot shows the overall fold changes per Chromatin-state. 
After this plot, wilcoxon test results are shown for those families for which the p-value is below an adjusted threshold.
This adjustment is done simply by dividing 0.05 by the number of distinct states.


```{r, fig.width=10, fig.height=15, eval=T}
chrom_plots = plots_2[['chrom']]
chrom_stats = stats_2[['chrom']]
for (poi in names(chrom_plots)){
	title = sprintf("fold change day %i\n%s",2,poi)
	grid.arrange(chrom_stats[[poi]], chrom_plots[[poi]],
		         top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,6))
}
chrom_plots = plots_wilcox_2[['chrom']]
for (poi in names(chrom_plots)){
	title = sprintf("fold change day %i %s",2,poi)
	for (state in names(chrom_plots[[poi]])){
		wc = chrom_plots[[poi]][[state]]
		grid.arrange(wc[[2]], wc[[1]],
			         top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,3))
	}
}
```

**Conclusion:**
State 14 and state 9 seem to have a population if barcodes that show a reduced suppression effect in the thetering experiment. State 14 includes intergrations in rRNA, so these are the same barcodes as shown in our analysis of the
intergrations in repeats. As you can see in the following chuck, there is no clear classification in the top part of state 9.

```{r, fig.width=10, fig.height=10, eval=T}
## filter data and get x and y
xy_table = filter_data(fc_table, 'chrom', 'KRAB_GPvsG_day2',poi='KRAB',day=2, xtype='factor',ytype='log2')
## select for the barcodes with log2 fc > 1 the columns with data on mapping and linking to states
high_fc = fc_table[rownames(xy_table[[1]])[which(xy_table[[1]][,2]>-1&xy_table[[1]]$x!='-')],43:ncol(fc_table)]
## create a plot with data
grid.arrange(tableGrob(high_fc[,1:15]),tableGrob(high_fc[,16:23]))
```
**remarks:**

mapq is mapping quality produced by bowtie and is a value for how unique the mapping location is. freq1 is the frequency of reads belonging to a barcode that were mapped to the top location. freq2 is the frequency for the second location. Wether the links between barcode and state are unique is decided upon in the data preperation script.

### fold-change on day 9, 11 and 12
Now let's look at the fold changes between GAL4-POI and GAL4 between different Chromatin state in the memory setting.
The first plot again shows the overall fold changes per Chromatin state. 
After this plot, wilcoxon test results are shown for those families for which the p-value is below an adjusted threshold.
This adjustment is done simply by dividing 0.05 by the number of distinct families.


```{r, fig.width=10, fig.height=15, eval=T}
chrom_plots = plots_9[['chrom']]
chrom_stats = stats_9[['chrom']]
for (poi in names(chrom_plots)){
	for (day in names(chrom_plots[[poi]]))
		title = sprintf("fold change day %s\n%s",day,poi)
		grid.arrange(chrom_stats[[poi]][[day]], chrom_plots[[poi]][[day]],
			         top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,6))
}
chrom_plots = plots_wilcox_9[['chrom']]
for (poi in names(chrom_plots)){
	for (day in names(chrom_plots[[poi]])){
		for (state in names(chrom_plots[[poi]][[day]])){
			title = sprintf("fold change day %s %s",day,poi)
			wc = chrom_plots[[poi]][[day]][[state]]
			grid.arrange(wc[[2]], wc[[1]],
			        	 top=textGrob(title, gp=gpar(fontsize=38)), heights=c(1,3))
		}
		
	}
}
```

**conclustion:**
There is a some sort of small tail in state 13. It appears that a subgroup of integrations
in state 13 shows memory. The tail seems to be the same for each protein of interest.




### correlation between expression on day 2 and fold change on day 9, 11 or 12
It could very well be that the amount of expression on day 2 is correlated with the occurence of memory.
It could be harder to keep the repressive state when there is a lot of signals to stimulate transcription.


```{r, fig.width=10, fig.height=25, eval=T}
chrom_plots = plots_expVs9[['chrom']]
chrom_stats = stats_expVs9[['chrom']]
chrom_corr = corr_expVs9[['chrom']]
for (poi in names(chrom_plots)){
	for (day in names(chrom_plots[[poi]])){
		title = sprintf("fold change day 2 vs day %s\n%s",day, poi)
		
		do.call(grid.arrange, c(chrom_corr[[poi]][[day]], ncol=3, top=list(textGrob(title, gp=gpar(fontsize=38)))))

		grid.arrange(chrom_stats[[poi]][[day]], chrom_plots[[poi]][[day]], top=list(textGrob(title, gp=gpar(fontsize=38))), heights=c(1,8))
	}
}
```

**conclusion:**
According to the spearman's correlation and pearson's correlation state 13 has a significant correlation between initial expression and fold change at day 11 and 12 in the KRAB and G9a experiment. Looking at the figures however, the amount of correlation is not that high.



### correlation between fold change on day 2 and day 9, 11 or 12
It could very well be that the amount of suppression on day 2 is correlated with the occurence of memory.
If it is harder for the transcription machinery to access the site on day 2, this could mean that the suppressive
chromatin state is more stable and more likely to be maintained.

```{r, fig.width=10, fig.height=25, eval=T}
chrom_plots = plots_2vs9[['chrom']]
chrom_stats = stats_2vs9[['chrom']]
chrom_corr = corr_2vs9[['chrom']]
for (poi in names(chrom_plots)){
	for (day in names(chrom_plots[[poi]])){
		title = sprintf("fold change day 2 vs day %s\n%s",day, poi)
		
		do.call(grid.arrange, c(chrom_corr[[poi]][[day]], ncol=3, top=list(textGrob(title, gp=gpar(fontsize=38)))))

		grid.arrange(chrom_stats[[poi]][[day]], chrom_plots[[poi]][[day]], top=list(textGrob(title, gp=gpar(fontsize=38))), heights=c(1,8))
	}
}
```
**conclusion:**
According to the spearman's correlation and pearson's correlation state 13 has a significant correlation between the fold-change after addition of POI-GAL4 on day 2 and the fold change at day 9 and 11 in the CBX5 and KRAB experiment. This does not seem to be the case for G9a, which also showed less of a memory effect.


```{r}
sessionInfo()
getwd()
date()
paste("Run time: ",format(Sys.time()-StartTime))
```
